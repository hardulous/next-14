RENDERING ::

Rendering is the process that transforms the code we write into user interfaces. In next.JS choosing the right time and place to do this rendering is vital for building a performant application. 

There are 3 types of rendering in next.JS ::

CSR , SSR and RSC

1. Client Side Rendering (CSR) => It is a type of rendering where pages or components are rendered entirely on the client (browser) rather than on the server. CSR is often used when you need interactive, dynamic content that heavily relies on browser-side logic, like data fetching after the page is loaded, handling user input, and more. CSR became the standard for single page application (SPA) but there are some drawbacks ::

 SEO => Generating HTML that contains only a single div tag is not optimal for SEO, as it provides little content for search engines to index.

 PERFORMACE => Having the browser (the client) handle all the work such as data fetching, making HTML interactive can slow things down. Each new feature added to the application increase the size of the JS bundle prolonging the wait time for users to see the UI. 

2. Server Side Rendering (SSR) => It allows us to render pages on the server at request time, providing pre-rendered HTML to improve performance, SEO, and initial load times. It solve the problem in CSR like SEO (because search engines can easily index the server-rendered content), User can immediately see the HTML content instead of a black screen or loading spinner becuase now page is already generated at server rather than done by client side js. 
 
  but there are some drawbacks ::

  In SSR when user make req to a page the server send the pre-rendered page to the client with js reference but the full interactivity of the page is on hold untill the js bundle comprising react along with app specific code has been completly downloaded and executed by the browser this process is called "HYDRATION" (It is where the static html page send by the server is brought to live. It is the process where a client-side JavaScript framework (like React) takes control over a pre-rendered HTML page (usually rendered server-side) and attaches event listeners, making the page interactive. In essence, it "rehydrates" the static HTML with dynamic behaviors.). 

  There are 2 server side solution 

  (a). Static Site Generation (SSG) => SSG occurs at build time, when application is eployed on the server. This result in pages that are already rendered and ready to serve. It is ideal for content that does not change often like blog, post, about etc..

  (b). SSR => Render pages on-demand in response to user requests. It is suitable for personalized content like social media feeds, Where the HTML depends on the logged-in user. Provide faster initial page loads and better SEO. 

  DRAWBACKS OF SSR ::

  (a). If a component needs to fetch data from a database or another source (like an API), this fetching must be completed before the server can begin rendering the page. This can delay the server's response time to the browser as the server must finish collecting all necessary data before any part of the page can be sent to the client. 

  (b). For successful hydration, Where react adds interactivity to the server-rendered HTML, the component tree in the browser must exactly match the server-generated component tree. This means all the js for the components must be loaded on the client before we can start hydrating any of them. 

  (c). Have to hydrate everything before we can interact with anything. React hydrate the component tree in a single pass, meaning once it started hydrating it will not stop untill it is finished with the entire tree. As a result all components must be hydrated before we can interact with any of them. 

  This is inefficent if some part of our app are slower than others in this case we still have to load the data for the entire page, Load the js for the entire page and hydrate the entire page. To solve this issue react 18 introduced "Suspense For SSR".
  
  In React CSR, Suspense is a feature used to manage asynchronous code and while code is getting downloaded will show loading states more as a placeholder value.

  When using Suspense in SSR, React can start rendering parts of the UI while it waits for data or code to load. This enables streaming, where parts of the HTML are sent to the client as they are ready, making the page load faster and more interactive, rather than waiting for the entire page to be ready.

  Now we do not have to fetch everything before we can show anything. If particular section delays ihe initial HTML, It can be seamlessly integrated into the stream later. Now initial page load is fast.

  Now to solve the issue where until js of our app is not loaded, client side app hydration cannot start we use "CODE SPITTING"

  Code spitting allows us to mark specific code segments as not immediately necessary for loading, signalling your bundler to segregate them into separate '<script>' tags. Using 'React.lazy' code of some part of application which is not immediately required is seprated from primary js bundle. 

  By this we are doing "SELECTIVE HYDRATION" which is hydration on demand when needed

  DRAWBACKS OF SUSPENSE SSR ::

  (a). Eventhough js code is streamed to the browser asynchronously, eventually the entire code for a web page must be downloaded by the user.

  (b). The current apprach requires that all react components undergo hydration on the client-side, irrespective of their actual need for interactivity. 

  (c). Inspite of server's superior capacity for handling intensive processing tasks, The bulk of js code still executes on user's device. This can slow down the performance on device which is not powerful. 



